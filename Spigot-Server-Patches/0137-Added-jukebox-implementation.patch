From 26bdf447ac67ab13f2c71dc080794421ceaef4d0 Mon Sep 17 00:00:00 2001
From: TomateDeveloper <ianfe@martina.com.co>
Date: Wed, 8 Jan 2020 23:03:08 -0500
Subject: [PATCH] Added jukebox implementation


diff --git a/src/main/java/org/bukkit/craftbukkit/Main.java b/src/main/java/org/bukkit/craftbukkit/Main.java
index c93621919..80b133662 100644
--- a/src/main/java/org/bukkit/craftbukkit/Main.java
+++ b/src/main/java/org/bukkit/craftbukkit/Main.java
@@ -196,6 +196,12 @@ public class Main {
                     System.out.println( "Warning, your max perm gen size is not set or less than 128mb. It is recommended you restart Java with the following argument: -XX:MaxPermSize=128M" );
                     System.out.println( "Please see http://www.spigotmc.org/wiki/changing-permgen-size/ for more details and more in-depth instructions." );
                 }
+
+
+                // Create song directory
+                File songDirectory = new File("songs");
+                if (!songDirectory.exists()) songDirectory.mkdir();
+
                 // Spigot End
                 System.out.println("Loading libraries, please wait...");
                 MinecraftServer.main(options);
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index ee47581d3..4759ddc92 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -22,6 +22,8 @@ import org.bukkit.conversations.ManuallyAbandonedConversationCanceller;
 import org.bukkit.craftbukkit.*;
 import org.bukkit.craftbukkit.block.CraftSign;
 import org.bukkit.craftbukkit.conversations.ConversationTracker;
+import org.bukkit.craftbukkit.jukebox.NBSDecoder;
+import org.bukkit.craftbukkit.jukebox.player.RadioSongPlayer;
 import org.bukkit.craftbukkit.map.CraftMapView;
 import org.bukkit.craftbukkit.map.RenderData;
 import org.bukkit.craftbukkit.scoreboard.CraftScoreboard;
@@ -32,6 +34,8 @@ import org.bukkit.entity.EntityType;
 import org.bukkit.entity.Player;
 import org.bukkit.event.player.*;
 import org.bukkit.inventory.InventoryView.Property;
+import org.bukkit.jukebox.instruments.partial.Song;
+import org.bukkit.jukebox.player.SongPlayer;
 import org.bukkit.map.MapCursor;
 import org.bukkit.map.MapView;
 import org.bukkit.metadata.MetadataValue;
@@ -42,6 +46,7 @@ import org.github.paperspigot.Title;
 
 import javax.annotation.Nullable;
 import java.io.ByteArrayOutputStream;
+import java.io.File;
 import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
@@ -55,7 +60,10 @@ import java.util.logging.Logger;
 
 @DelegateDeserialization(CraftOfflinePlayer.class)
 public class CraftPlayer extends CraftHumanEntity implements Player {
+
+    private byte playerVolume = 100;
     private Set<Hologram> holograms = new HashSet<>();
+    private List<SongPlayer> songPlayer = new ArrayList<>();
     private String databaseIdentifier = "";
     private long firstPlayed = 0;
     private long lastPlayed = 0;
@@ -1489,6 +1497,38 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         if (this.databaseIdentifier.equalsIgnoreCase("")) this.databaseIdentifier = identifier;
     }
 
+    @Override
+    public byte getPlayerVolume() {
+        return this.playerVolume;
+    }
+
+    @Override
+    public void setPlayerVolume(byte volume) {
+        this.playerVolume = volume;
+    }
+
+    @Override
+    public void stopPlayingSong() {
+        this.songPlayer.get(0).removePlayer(this);
+        this.songPlayer.clear();
+    }
+
+    @Override
+    public void playSong(String fileName) {
+        File songFile = new File("song/" + fileName + ".nbs");
+        if (!songFile.exists() || songFile.isDirectory()) throw new IllegalArgumentException("The song file could not be found");
+        Song song = NBSDecoder.parse(songFile);
+        RadioSongPlayer radioPlayer = new RadioSongPlayer(song);
+        radioPlayer.addPlayer(this);
+        this.songPlayer.clear();
+        this.songPlayer.add(radioPlayer);
+    }
+
+    @Override
+    public boolean isReceivingSong() {
+        return this.songPlayer.size() >= 1;
+    }
+
     @Override
     public void setVelocity(org.bukkit.util.Vector velocity) {
         // Send the new velocity to the player's client immediately, so it isn't affected by
diff --git a/src/main/java/org/bukkit/craftbukkit/jukebox/NBSDecoder.java b/src/main/java/org/bukkit/craftbukkit/jukebox/NBSDecoder.java
new file mode 100644
index 000000000..723433a40
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/jukebox/NBSDecoder.java
@@ -0,0 +1,112 @@
+package org.bukkit.craftbukkit.jukebox;
+
+import org.bukkit.craftbukkit.jukebox.instruments.partial.CraftLayer;
+import org.bukkit.craftbukkit.jukebox.instruments.partial.CraftNote;
+import org.bukkit.craftbukkit.jukebox.instruments.partial.CraftSong;
+import org.bukkit.jukebox.instruments.partial.*;
+
+import java.io.*;
+import java.util.HashMap;
+
+public class NBSDecoder {
+
+    public static Song parse(File decodeFile) {
+        try {
+            return parse(new FileInputStream(decodeFile), decodeFile);
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    public static Song parse(InputStream inputStream) {
+        return parse(inputStream, null);
+    }
+
+    private static Song parse(InputStream inputStream, File decodeFile) {
+        HashMap<Integer, Layer> layerHashMap = new HashMap<>();
+        try {
+            DataInputStream dis = new DataInputStream(inputStream);
+            short length = readShort(dis);
+            short songHeight = readShort(dis);
+            String title = readString(dis);
+            String author = readString(dis);
+            readString(dis);
+            String description = readString(dis);
+            float speed = readShort(dis) / 100f;
+            dis.readBoolean();
+            dis.readByte();
+            dis.readByte();
+            readInt(dis);
+            readInt(dis);
+            readInt(dis);
+            readInt(dis);
+            readInt(dis);
+            readString(dis);
+            short tick = -1;
+            while (true) {
+                short jumpTicks = readShort(dis);
+                if (jumpTicks == 0) {
+                    break;
+                }
+                tick += jumpTicks;
+                short layer = -1;
+                while (true) {
+                    short jumpLayers = readShort(dis); // jumps till next layer
+                    if (jumpLayers == 0) {
+                        break;
+                    }
+                    layer += jumpLayers;
+                    setNote(layer, tick, dis.readByte() /* instrument */, dis.readByte() /* note */, layerHashMap);
+                }
+            }
+            for (int i = 0; i < songHeight; i++) {
+                Layer l = layerHashMap.get(i);
+                if (l != null) {
+                    l.setName(readString(dis));
+                    l.setVolume(dis.readByte());
+                }
+            }
+            return new CraftSong(speed, layerHashMap, songHeight, length, title, author, description, decodeFile);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    private static void setNote(int layer, int ticks, byte instrument, byte key, HashMap<Integer, Layer> layerHashMap) {
+        Layer l = layerHashMap.get(layer);
+        if (l == null) {
+            l = new CraftLayer();
+            layerHashMap.put(layer, l);
+        }
+        l.setNote(ticks, new CraftNote(instrument, key));
+    }
+
+    private static short readShort(DataInputStream dis) throws IOException {
+        int byte1 = dis.readUnsignedByte();
+        int byte2 = dis.readUnsignedByte();
+        return (short) (byte1 + (byte2 << 8));
+    }
+
+    private static int readInt(DataInputStream dis) throws IOException {
+        int byte1 = dis.readUnsignedByte();
+        int byte2 = dis.readUnsignedByte();
+        int byte3 = dis.readUnsignedByte();
+        int byte4 = dis.readUnsignedByte();
+        return (byte1 + (byte2 << 8) + (byte3 << 16) + (byte4 << 24));
+    }
+
+    private static String readString(DataInputStream dis) throws IOException {
+        int length = readInt(dis);
+        StringBuilder sb = new StringBuilder(length);
+        for (; length > 0; --length) {
+            char c = (char) dis.readByte();
+            if (c == (char) 0x0D) {
+                c = ' ';
+            }
+            sb.append(c);
+        }
+        return sb.toString();
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/jukebox/instruments/partial/CraftLayer.java b/src/main/java/org/bukkit/craftbukkit/jukebox/instruments/partial/CraftLayer.java
new file mode 100644
index 000000000..2afc11f15
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/jukebox/instruments/partial/CraftLayer.java
@@ -0,0 +1,38 @@
+package org.bukkit.craftbukkit.jukebox.instruments.partial;
+
+import org.bukkit.jukebox.instruments.partial.Layer;
+import org.bukkit.jukebox.instruments.partial.Note;
+
+import java.util.HashMap;
+
+public class CraftLayer implements Layer {
+
+    private HashMap<Integer, Note> hashMap = new HashMap<>();
+    private byte volume = 100;
+    private String name = "";
+
+    @Override
+    public Note getNote(int tick) {
+        return hashMap.get(tick);
+    }
+
+    @Override
+    public void setNote(int tick, Note note) {
+        hashMap.put(tick, note);
+    }
+
+    @Override
+    public byte getVolume() {
+        return volume;
+    }
+
+    @Override
+    public void setVolume(byte volume) {
+        this.volume = volume;
+    }
+
+    @Override
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/jukebox/instruments/partial/CraftNote.java b/src/main/java/org/bukkit/craftbukkit/jukebox/instruments/partial/CraftNote.java
new file mode 100644
index 000000000..020e2bd09
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/jukebox/instruments/partial/CraftNote.java
@@ -0,0 +1,25 @@
+package org.bukkit.craftbukkit.jukebox.instruments.partial;
+
+import org.bukkit.jukebox.instruments.partial.Note;
+
+public class CraftNote implements Note {
+
+    private byte instrument;
+    private byte key;
+
+    public CraftNote(byte instrument, byte key) {
+        this.instrument = instrument;
+        this.key = key;
+    }
+
+    @Override
+    public byte getInstrument() {
+        return instrument;
+    }
+
+    @Override
+    public byte getKey() {
+        return key;
+    }
+
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/jukebox/instruments/partial/CraftSong.java b/src/main/java/org/bukkit/craftbukkit/jukebox/instruments/partial/CraftSong.java
new file mode 100644
index 000000000..6b6d4afa2
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/jukebox/instruments/partial/CraftSong.java
@@ -0,0 +1,85 @@
+package org.bukkit.craftbukkit.jukebox.instruments.partial;
+
+import org.bukkit.jukebox.instruments.partial.Layer;
+import org.bukkit.jukebox.instruments.partial.Song;
+
+import java.io.File;
+import java.util.HashMap;
+
+public class CraftSong implements Song {
+
+    private HashMap<Integer, Layer> layerHashMap;
+    private short songHeight;
+    private short length;
+    private String title;
+    private File path;
+    private String author;
+    private String description;
+    private float speed;
+    private float delay;
+
+    public CraftSong(CraftSong other) {
+        this.speed = other.getSpeed();
+        delay = 20 / speed;
+        this.layerHashMap = other.getLayerHashMap();
+        this.songHeight = other.getSongHeight();
+        this.length = other.getLength();
+        this.title = other.getTitle();
+        this.author = other.getAuthor();
+        this.description = other.getDescription();
+        this.path = other.getPath();
+    }
+
+    public CraftSong(float speed, HashMap<Integer, Layer> layerHashMap,
+                     short songHeight, final short length, String title, String author,
+                     String description, File path) {
+        this.speed = speed;
+        delay = 20 / speed;
+        this.layerHashMap = layerHashMap;
+        this.songHeight = songHeight;
+        this.length = length;
+        this.title = title;
+        this.author = author;
+        this.description = description;
+        this.path = path;
+    }
+
+    @Override
+    public HashMap<Integer, Layer> getLayerHashMap() {
+        return layerHashMap;
+    }
+
+    private short getSongHeight() {
+        return songHeight;
+    }
+
+    @Override
+    public short getLength() {
+        return length;
+    }
+
+    private String getTitle() {
+        return title;
+    }
+
+    private String getAuthor() {
+        return author;
+    }
+
+    private File getPath() {
+        return path;
+    }
+
+    private String getDescription() {
+        return description;
+    }
+
+    private float getSpeed() {
+        return speed;
+    }
+
+    @Override
+    public float getDelay() {
+        return delay;
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/jukebox/player/CraftSongPlayer.java b/src/main/java/org/bukkit/craftbukkit/jukebox/player/CraftSongPlayer.java
new file mode 100644
index 000000000..3eb1f8ba8
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/jukebox/player/CraftSongPlayer.java
@@ -0,0 +1,273 @@
+package org.bukkit.craftbukkit.jukebox.player;
+
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.jukebox.NoteBlockPlayerMain;
+import org.bukkit.event.jukebox.SongDestroyingEvent;
+import org.bukkit.event.jukebox.SongEndEvent;
+import org.bukkit.event.jukebox.SongStoppedEvent;
+import org.bukkit.jukebox.instruments.FadeType;
+import org.bukkit.jukebox.instruments.Interpolator;
+import org.bukkit.jukebox.instruments.partial.Song;
+import org.bukkit.entity.Player;
+import org.bukkit.jukebox.player.SongPlayer;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+public abstract class CraftSongPlayer implements SongPlayer {
+
+    private boolean playing;
+    private short tick;
+    private ArrayList<String> playerList;
+    private boolean loop;
+    private boolean autoDestroy;
+    private boolean destroyed;
+    private byte fadeTarget;
+    private byte fadeStart;
+    private int fadeDuration;
+    private int fadeDone;
+    private FadeType fadeType = FadeType.FADE_LINEAR;
+    private byte volume;
+    private Song song;
+
+    CraftSongPlayer(Song song) {
+        this.song = song;
+        this.playing = false;
+        this.tick = -1;
+        this.playerList = new ArrayList<>();
+        this.autoDestroy = false;
+        this.destroyed = false;
+        this.volume = 100;
+        this.fadeTarget = 100;
+        this.fadeStart = volume;
+        this.fadeDuration = 60;
+        this.fadeDone = 0;
+        createThread();
+    }
+
+    @Override
+    public FadeType getFadeType() {
+        return fadeType;
+    }
+
+    @Override
+    public void setFadeType(FadeType fadeType) {
+        this.fadeType = fadeType;
+    }
+
+    @Override
+    public byte getFadeTarget() {
+        return fadeTarget;
+    }
+
+    @Override
+    public void setFadeTarget(byte fadeTarget) {
+        this.fadeTarget = fadeTarget;
+    }
+
+    @Override
+    public byte getFadeStart() {
+        return fadeStart;
+    }
+
+    @Override
+    public void setFadeStart(byte fadeStart) {
+        this.fadeStart = fadeStart;
+    }
+
+    @Override
+    public int getFadeDuration() {
+        return fadeDuration;
+    }
+
+    @Override
+    public void setFadeDuration(int fadeDuration) {
+        this.fadeDuration = fadeDuration;
+    }
+
+    @Override
+    public int getFadeDone() {
+        return fadeDone;
+    }
+
+    @Override
+    public void setFadeDone(int fadeDone) {
+        this.fadeDone = fadeDone;
+    }
+
+    private void calculateFade() {
+        if (fadeDone == fadeDuration) {
+            return;
+        }
+        double targetVolume = Interpolator.interpLinear(new double[]{0, fadeStart, fadeDuration, fadeTarget}, fadeDone);
+        setVolume((byte) targetVolume);
+        fadeDone++;
+    }
+
+    private void createThread() {
+        Thread playerThread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                while (!destroyed) {
+                    long startTime = System.currentTimeMillis();
+                    synchronized (CraftSongPlayer.this) {
+                        if (playing) {
+                            calculateFade();
+                            tick++;
+                            if (tick > song.getLength()) {
+                                if (loop) {
+                                    tick = 0;
+                                    continue;
+                                }
+                                playing = false;
+                                tick = -1;
+                                SongEndEvent event = new SongEndEvent(CraftSongPlayer.this);
+                                Bukkit.getPluginManager().callEvent(event);
+                                if (autoDestroy) {
+                                    destroy();
+                                    return;
+                                }
+                            }
+                            for (String s : playerList) {
+                                Player p = Bukkit.getPlayerExact(s);
+                                if (p == null) {
+                                    continue;
+                                }
+                                playTick(p, tick);
+                            }
+                        }
+                    }
+                    long duration = System.currentTimeMillis() - startTime;
+                    float delayMillis = song.getDelay() * 50;
+                    if (duration < delayMillis) {
+                        try {
+                            Thread.sleep((long) (delayMillis - duration));
+                        } catch (InterruptedException ignore) {}
+                    }
+                }
+            }
+        });
+        playerThread.setPriority(Thread.MAX_PRIORITY);
+        playerThread.start();
+    }
+
+    @Override
+    public List<String> getPlayerList() {
+        return Collections.unmodifiableList(playerList);
+    }
+
+    @Override
+    public void addPlayer(Player p) {
+        synchronized (this) {
+            if (!playerList.contains(p.getName())) {
+                playerList.add(p.getName());
+                ArrayList<CraftSongPlayer> songs = NoteBlockPlayerMain.plugin.playingSongs
+                        .get(p.getName());
+                if (songs == null) {
+                    songs = new ArrayList<>();
+                }
+                songs.add(this);
+                NoteBlockPlayerMain.plugin.playingSongs.put(p.getName(), songs);
+            }
+        }
+    }
+
+    @Override
+    public boolean isLoop() {
+        synchronized (this) {
+            return this.loop;
+        }
+    }
+
+    @Override
+    public void setLoop(boolean loop) {
+        synchronized (this) {
+            this.loop = loop;
+        }
+    }
+
+    @Override
+    public boolean getAutoDestroy() {
+        synchronized (this) {
+            return autoDestroy;
+        }
+    }
+
+    @Override
+    public void setAutoDestroy(boolean value) {
+        synchronized (this) {
+            autoDestroy = value;
+        }
+    }
+
+    private void destroy() {
+        synchronized (this) {
+            SongDestroyingEvent event = new SongDestroyingEvent(this);
+            Bukkit.getPluginManager().callEvent(event);
+            if (event.isCancelled()) {
+                return;
+            }
+            destroyed = true;
+            playing = false;
+            setTick((short) -1);
+        }
+    }
+
+    @Override
+    public boolean isPlaying() {
+        return playing;
+    }
+
+    @Override
+    public void setPlaying(boolean playing) {
+        this.playing = playing;
+        if (!playing) {
+            SongStoppedEvent event = new SongStoppedEvent(this);
+            Bukkit.getPluginManager().callEvent(event);
+        }
+    }
+
+    @Override
+    public short getTick() {
+        return tick;
+    }
+
+    private void setTick(short tick) {
+        this.tick = tick;
+    }
+
+    @Override
+    public void removePlayer(Player p) {
+        synchronized (this) {
+            playerList.remove(p.getName());
+            if (NoteBlockPlayerMain.plugin.playingSongs.get(p.getName()) == null) {
+                return;
+            }
+            ArrayList<CraftSongPlayer> songs = new ArrayList<>(
+                    NoteBlockPlayerMain.plugin.playingSongs.get(p.getName()));
+            songs.remove(this);
+            NoteBlockPlayerMain.plugin.playingSongs.put(p.getName(), songs);
+            if (playerList.isEmpty() && autoDestroy) {
+                SongEndEvent event = new SongEndEvent(this);
+                Bukkit.getPluginManager().callEvent(event);
+                destroy();
+            }
+        }
+    }
+
+    @Override
+    public byte getVolume() {
+        return volume;
+    }
+
+    private void setVolume(byte volume) {
+        this.volume = volume;
+    }
+
+    @Override
+    public Song getSong() {
+        return song;
+    }
+
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/jukebox/player/NoteBlockSongPlayer.java b/src/main/java/org/bukkit/craftbukkit/jukebox/player/NoteBlockSongPlayer.java
new file mode 100644
index 000000000..2820e6151
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/jukebox/player/NoteBlockSongPlayer.java
@@ -0,0 +1,47 @@
+package org.bukkit.craftbukkit.jukebox.player;
+
+import net.seocraft.jukebox.*;
+import net.seocraft.jukebox.instruments.Instrument;
+import net.seocraft.jukebox.instruments.NotePitch;
+import net.seocraft.jukebox.instruments.partial.Layer;
+import net.seocraft.jukebox.instruments.partial.Note;
+import net.seocraft.jukebox.instruments.partial.Song;
+import org.bukkit.Material;
+import org.bukkit.block.Block;
+import org.bukkit.entity.Player;
+
+public class NoteBlockSongPlayer extends CraftSongPlayer {
+
+    private Block noteBlock;
+
+    public NoteBlockSongPlayer(Song song) {
+        super(song);
+    }
+
+    public Block getNoteBlock() {
+        return noteBlock;
+    }
+
+    public void setNoteBlock(Block noteBlock) {
+        this.noteBlock = noteBlock;
+    }
+
+    @Override
+    public void playTick(Player p, int tick) {
+        if (noteBlock.getType() != Material.NOTE_BLOCK) return;
+        if (!p.getWorld().getName().equals(noteBlock.getWorld().getName())) return;
+
+        byte playerVolume = NoteBlockPlayerMain.getPlayerVolume(p);
+
+        for (Layer l : getSong().getLayerHashMap().values()) {
+            Note note = l.getNote(tick);
+            if (note == null) continue;
+            p.playNote(noteBlock.getLocation(), Instrument.getBukkitInstrument(note.getInstrument()),
+                    new org.bukkit.Note(note.getKey() - 33));
+            p.playSound(noteBlock.getLocation(),
+                    Instrument.getInstrument(note.getInstrument()),
+                    (l.getVolume() * (int) getVolume() * (int) playerVolume) / 1000000f,
+                    NotePitch.getPitch(note.getKey() - 33));
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/jukebox/player/PositionSongPlayer.java b/src/main/java/org/bukkit/craftbukkit/jukebox/player/PositionSongPlayer.java
new file mode 100644
index 000000000..89043c795
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/jukebox/player/PositionSongPlayer.java
@@ -0,0 +1,43 @@
+package org.bukkit.craftbukkit.jukebox.player;
+
+import net.seocraft.jukebox.*;
+import net.seocraft.jukebox.instruments.Instrument;
+import net.seocraft.jukebox.instruments.NotePitch;
+import net.seocraft.jukebox.instruments.partial.Layer;
+import net.seocraft.jukebox.instruments.partial.Note;
+import net.seocraft.jukebox.instruments.partial.Song;
+import org.bukkit.Location;
+import org.bukkit.entity.Player;
+
+public class PositionSongPlayer extends CraftSongPlayer {
+
+    private Location targetLocation;
+
+    public PositionSongPlayer(Song song) {
+        super(song);
+    }
+
+    public Location getTargetLocation() {
+        return targetLocation;
+    }
+
+    public void setTargetLocation(Location targetLocation) {
+        this.targetLocation = targetLocation;
+    }
+
+    @Override
+    public void playTick(Player p, int tick) {
+        if (!p.getWorld().getName().equals(targetLocation.getWorld().getName())) return;
+
+        byte playerVolume = NoteBlockPlayerMain.getPlayerVolume(p);
+
+        for (Layer l : getSong().getLayerHashMap().values()) {
+            Note note = l.getNote(tick);
+            if (note == null) continue;
+            p.playSound(targetLocation,
+                    Instrument.getInstrument(note.getInstrument()),
+                    (l.getVolume() * (int) getVolume() * (int) playerVolume) / 1000000f,
+                    NotePitch.getPitch(note.getKey() - 33));
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/jukebox/player/RadioSongPlayer.java b/src/main/java/org/bukkit/craftbukkit/jukebox/player/RadioSongPlayer.java
new file mode 100644
index 000000000..74ff57d19
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/jukebox/player/RadioSongPlayer.java
@@ -0,0 +1,31 @@
+package org.bukkit.craftbukkit.jukebox.player;
+
+import org.bukkit.jukebox.instruments.Instrument;
+import org.bukkit.jukebox.instruments.NotePitch;
+import org.bukkit.jukebox.instruments.partial.Layer;
+import org.bukkit.jukebox.instruments.partial.Note;
+import org.bukkit.jukebox.instruments.partial.Song;
+import org.bukkit.entity.Player;
+
+public class RadioSongPlayer extends CraftSongPlayer {
+
+    public RadioSongPlayer(Song song) {
+        super(song);
+    }
+
+    @Override
+    public void playTick(Player p, int tick) {
+        byte playerVolume = p.getPlayerVolume();
+
+        for (Layer l : getSong().getLayerHashMap().values()) {
+            Note note = l.getNote(tick);
+            if (note == null) {
+                continue;
+            }
+            p.playSound(p.getEyeLocation(),
+                    Instrument.getInstrument(note.getInstrument()),
+                    (l.getVolume() * (int) getVolume() * (int) playerVolume) / 1000000f,
+                    NotePitch.getPitch(note.getKey() - 33));
+        }
+    }
+}
-- 
2.22.0.windows.1

